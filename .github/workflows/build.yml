name: Build and Release

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  RENPY_VERSION: "8.3.3"
  PROJECT_NAME: "CouncilOfChalcedon"
  APP_NAME: "Council of Chalcedon"

jobs:
  version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.bump.outputs.version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Calculate and bump version
        id: bump
        run: |
          VERSION="1.0.$(git rev-list --count HEAD)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Bumping to version: $VERSION"

          # Update version in options.rpy
          sed -i "s/define config.version = .*/define config.version = \"$VERSION\"/" game/options.rpy

          # Show the change
          grep "config.version" game/options.rpy

      - name: Commit version bump
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add game/options.rpy
          git diff --cached --quiet || git commit -m "Bump version to ${{ steps.bump.outputs.version }}"
          git push

  build:
    needs: version
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
          - os: ubuntu-latest
            platform: win
          - os: macos-latest
            platform: mac

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Pull latest (with version bump)
        run: git pull origin main

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Download Ren'Py SDK
        run: |
          curl -L -o renpy-sdk.tar.bz2 "https://www.renpy.org/dl/${{ env.RENPY_VERSION }}/renpy-${{ env.RENPY_VERSION }}-sdk.tar.bz2"
          tar xjf renpy-sdk.tar.bz2
          mv renpy-${{ env.RENPY_VERSION }}-sdk renpy-sdk

      - name: Build for ${{ matrix.platform }}
        run: |
          ./renpy-sdk/renpy.sh ./renpy-sdk/launcher distribute . --package ${{ matrix.platform }}

      - name: Find and rename build output
        run: |
          echo "Looking for dists folder..."
          ls -la
          DISTS_DIR=$(ls -d ${{ env.PROJECT_NAME }}-*-dists 2>/dev/null | head -1)
          if [ -z "$DISTS_DIR" ]; then
            echo "No dists folder found!"
            exit 1
          fi
          echo "Found: $DISTS_DIR"
          mv "$DISTS_DIR" dists
          ls -la dists/

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-${{ matrix.platform }}
          path: dists/*

  appimage:
    needs: [version, build]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Linux artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-linux
          path: linux-artifact

      - name: Extract Linux build
        run: |
          cd linux-artifact
          tar xjf *.tar.bz2
          ls -la

      - name: Create AppImage
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          # Find the extracted app directory
          APP_DIR=$(find linux-artifact -maxdepth 1 -type d -name "CouncilOfChalcedon-*" | head -1)
          echo "App directory: $APP_DIR"

          # Create AppDir structure
          mkdir -p AppDir/usr/bin
          mkdir -p AppDir/usr/share/applications
          mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps

          # Copy application files
          cp -r "$APP_DIR"/* AppDir/usr/bin/

          # Copy icon
          cp icon.png AppDir/usr/share/icons/hicolor/256x256/apps/council-of-chalcedon.png
          cp icon.png AppDir/council-of-chalcedon.png

          # Create desktop file
          cat > AppDir/council-of-chalcedon.desktop << 'EOF'
          [Desktop Entry]
          Type=Application
          Name=Council of Chalcedon
          Comment=An educational kinetic novel re-enacting the Fourth Ecumenical Council (451 AD)
          Exec=CouncilOfChalcedon.sh
          Icon=council-of-chalcedon
          Categories=Game;Education;
          Terminal=false
          EOF

          cp AppDir/council-of-chalcedon.desktop AppDir/usr/share/applications/

          # Create AppRun script
          cat > AppDir/AppRun << 'EOF'
          #!/bin/bash
          SELF=$(readlink -f "$0")
          HERE=${SELF%/*}
          export PATH="${HERE}/usr/bin:${PATH}"
          cd "${HERE}/usr/bin"
          exec ./CouncilOfChalcedon.sh "$@"
          EOF
          chmod +x AppDir/AppRun

          # Download appimagetool
          wget -q "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
          chmod +x appimagetool-x86_64.AppImage

          # Create AppImage
          ARCH=x86_64 ./appimagetool-x86_64.AppImage --appimage-extract-and-run AppDir "CouncilOfChalcedon-${VERSION}-linux.AppImage"

          ls -la *.AppImage

      - name: Upload AppImage artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-appimage
          path: "*.AppImage"

  msi:
    needs: [version, build]
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-win
          path: win-artifact

      - name: Extract Windows build
        shell: pwsh
        run: |
          $zipFile = Get-ChildItem -Path win-artifact -Filter "*.zip" | Select-Object -First 1
          Write-Host "Extracting: $($zipFile.FullName)"
          Expand-Archive -Path $zipFile.FullName -DestinationPath "app" -Force
          Get-ChildItem -Path app -Recurse | Select-Object FullName

      - name: Install WiX Toolset
        shell: pwsh
        run: |
          dotnet tool install --global wix --version 4.0.5
          wix extension add WixToolset.UI.wixext/4.0.5

      - name: Create MSI installer
        shell: pwsh
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          $appDir = Get-ChildItem -Path app -Directory | Select-Object -First 1
          Write-Host "App directory: $($appDir.FullName)"

          # Copy icon to app directory
          Copy-Item "icon.ico" -Destination $appDir.FullName -ErrorAction SilentlyContinue

          # First, harvest all files using wix heat
          Write-Host "Harvesting files from $($appDir.FullName)..."
          wix heat dir $appDir.FullName -cg ProductComponents -dr INSTALLFOLDER -srd -sreg -gg -sfrag -out files.wxs

          # Create main installer WiX source
          $wxs = @"
          <?xml version="1.0" encoding="UTF-8"?>
          <Wix xmlns="http://wixtoolset.org/schemas/v4/wxs"
               xmlns:ui="http://wixtoolset.org/schemas/v4/wxs/ui">
            <Package Name="Council of Chalcedon"
                     Version="$env:VERSION"
                     Manufacturer="John VonDrashek"
                     UpgradeCode="8B5E8A3C-9F4D-4E6A-B7C8-2D1E0F3A4B5C"
                     Scope="perUser">
              <MajorUpgrade DowngradeErrorMessage="A newer version is already installed." />
              <MediaTemplate EmbedCab="yes" CompressionLevel="high" />
              <Icon Id="AppIcon" SourceFile="icon.ico" />
              <Property Id="ARPPRODUCTICON" Value="AppIcon" />
              <Property Id="ARPHELPLINK" Value="https://github.com/JohnVonDrashek/council-of-chalcedon-vn" />
              <StandardDirectory Id="LocalAppDataFolder">
                <Directory Id="INSTALLFOLDER" Name="Council of Chalcedon" />
              </StandardDirectory>
              <StandardDirectory Id="ProgramMenuFolder">
                <Directory Id="ProgramMenuDir" Name="Council of Chalcedon">
                  <Component Id="StartMenuShortcut" Guid="a1b2c3d4-e5f6-7890-abcd-ef1234567890">
                    <Shortcut Id="StartMenuShortcut" Name="Council of Chalcedon" Target="[INSTALLFOLDER]CouncilOfChalcedon.exe" WorkingDirectory="INSTALLFOLDER" Icon="AppIcon" />
                    <RemoveFolder Id="ProgramMenuDir" On="uninstall" />
                    <RegistryValue Root="HKCU" Key="Software\CouncilOfChalcedon" Name="Installed" Type="integer" Value="1" KeyPath="yes" />
                  </Component>
                </Directory>
              </StandardDirectory>
              <StandardDirectory Id="DesktopFolder">
                <Component Id="DesktopShortcut" Guid="b2c3d4e5-f6a7-8901-bcde-f23456789012">
                  <Shortcut Id="DesktopShortcut" Name="Council of Chalcedon" Target="[INSTALLFOLDER]CouncilOfChalcedon.exe" WorkingDirectory="INSTALLFOLDER" Icon="AppIcon" />
                  <RegistryValue Root="HKCU" Key="Software\CouncilOfChalcedon" Name="DesktopShortcut" Type="integer" Value="1" KeyPath="yes" />
                </Component>
              </StandardDirectory>
              <Feature Id="ProductFeature" Title="Council of Chalcedon">
                <ComponentGroupRef Id="ProductComponents" />
                <ComponentRef Id="StartMenuShortcut" />
                <ComponentRef Id="DesktopShortcut" />
              </Feature>
              <ui:WixUI Id="WixUI_InstallDir" InstallDirectory="INSTALLFOLDER" />
            </Package>
          </Wix>
          "@

          $wxs | Out-File -FilePath "installer.wxs" -Encoding UTF8
          Write-Host "Main installer.wxs:"
          Get-Content "installer.wxs"

          # Build MSI with both files
          Write-Host "Building MSI..."
          wix build installer.wxs files.wxs -ext WixToolset.UI.wixext -bindpath $appDir.FullName -o "CouncilOfChalcedon-$env:VERSION-win.msi"

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-msi
          path: "*.msi"

  release:
    needs: [version, build, appimage, msi]
    runs-on: macos-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: |
          echo "Contents of artifacts folder:"
          ls -laR artifacts/ || echo "No artifacts folder"

      - name: Prepare release files
        run: |
          mkdir -p release

          # Find and copy release files
          find artifacts -name "*.zip" -exec cp {} release/ \;
          find artifacts -name "*.tar.bz2" -exec cp {} release/ \;
          find artifacts -name "*.dmg" -exec cp {} release/ \;
          find artifacts -name "*.msi" -exec cp {} release/ \;
          find artifacts -name "*.AppImage" -exec cp {} release/ \;
          find artifacts -name "*.app" -type d -exec sh -c 'cd "$(dirname "{}")" && zip -r "../$(basename "{}").zip" "$(basename "{}")"' \;

          ls -la release/

      - name: Sign and Notarize macOS build
        if: env.CERTIFICATE_P12_BASE64 != ''
        continue-on-error: true
        env:
          CERTIFICATE_P12_BASE64: ${{ secrets.CERTIFICATE_P12_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          echo "$CERTIFICATE_P12_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Find the signing identity
          IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          echo "Signing with: $IDENTITY"

          # Create entitlements file for Ren'Py/Python
          cat > entitlements.plist << 'ENTITLEMENTS'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>com.apple.security.cs.allow-jit</key>
            <true/>
            <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
            <true/>
            <key>com.apple.security.cs.disable-library-validation</key>
            <true/>
            <key>com.apple.security.automation.apple-events</key>
            <true/>
          </dict>
          </plist>
          ENTITLEMENTS

          # Find and extract the mac zip to get the .app
          MAC_ZIP=$(find artifacts -name "*-mac.zip" | head -1)
          if [ -n "$MAC_ZIP" ]; then
            echo "Found mac zip: $MAC_ZIP"
            mkdir -p mac_extracted
            unzip -o "$MAC_ZIP" -d mac_extracted

            MAC_APP=$(find mac_extracted -name "*.app" -type d | head -1)
            echo "Found app: $MAC_APP"

            if [ -n "$MAC_APP" ]; then
              echo "Signing all binaries in the app bundle..."

              # Remove any existing signatures and xattr quarantine flags
              xattr -cr "$MAC_APP"

              # Sign all .so files (Python extensions)
              find "$MAC_APP" -name "*.so" -type f | while read -r lib; do
                echo "Signing .so: $lib"
                codesign --force --sign "$IDENTITY" --options runtime --timestamp --entitlements entitlements.plist "$lib" || true
              done

              # Sign all .dylib files
              find "$MAC_APP" -name "*.dylib" -type f | while read -r lib; do
                echo "Signing .dylib: $lib"
                codesign --force --sign "$IDENTITY" --options runtime --timestamp --entitlements entitlements.plist "$lib" || true
              done

              # Sign ALL Mach-O binaries anywhere in the bundle
              # Don't rely on execute permissions - check actual file type
              echo "Scanning for all Mach-O binaries..."
              find "$MAC_APP" -type f ! -name "*.py" ! -name "*.sh" ! -name "*.rpy" ! -name "*.txt" ! -name "*.json" ! -name "*.png" ! -name "*.jpg" ! -name "*.rpa" ! -name "*.rpyc" | while read -r bin; do
                # Check if it's a Mach-O binary
                if file "$bin" 2>/dev/null | grep -q "Mach-O"; then
                  echo "Signing Mach-O: $bin"
                  codesign --force --sign "$IDENTITY" --options runtime --timestamp --entitlements entitlements.plist "$bin" || true
                fi
              done

              # Sign any framework bundles (innermost first)
              find "$MAC_APP" -name "*.framework" -type d -depth | while read -r framework; do
                echo "Signing framework: $framework"
                codesign --force --sign "$IDENTITY" --options runtime --timestamp --entitlements entitlements.plist "$framework" || true
              done

              # Sign any nested .app bundles (innermost first) - like renpy.app
              find "$MAC_APP" -name "*.app" -type d -depth | while read -r nested_app; do
                if [ "$nested_app" != "$MAC_APP" ]; then
                  echo "Signing nested app: $nested_app"
                  codesign --force --sign "$IDENTITY" --options runtime --timestamp --entitlements entitlements.plist "$nested_app" || true
                fi
              done

              # Finally sign the main app bundle
              echo "Signing main app bundle..."
              codesign --force --sign "$IDENTITY" --options runtime --timestamp --entitlements entitlements.plist "$MAC_APP"

              # Verify the signature
              echo "Verifying signature..."
              codesign --verify --deep --strict --verbose=2 "$MAC_APP" || echo "Warning: Signature verification had issues"

              # Create professional DMG with proper installer layout
              VERSION="${{ needs.version.outputs.version }}"
              DMG_NAME="${{ env.PROJECT_NAME }}-${VERSION}-macOS.dmg"

              # Install create-dmg for professional DMG creation
              brew install create-dmg

              # Create DMG with proper icon positioning and styling
              create-dmg \
                --volname "${{ env.APP_NAME }}" \
                --window-pos 200 120 \
                --window-size 600 400 \
                --icon-size 100 \
                --icon "CouncilOfChalcedon.app" 150 185 \
                --hide-extension "CouncilOfChalcedon.app" \
                --app-drop-link 450 185 \
                --no-internet-enable \
                "release/$DMG_NAME" \
                "$MAC_APP"

              # Sign the DMG
              codesign --force --sign "$IDENTITY" --timestamp "release/$DMG_NAME"

              # Notarize and capture submission ID
              echo "Submitting for notarization..."
              SUBMIT_OUTPUT=$(xcrun notarytool submit "release/$DMG_NAME" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" \
                --wait 2>&1) || true
              echo "$SUBMIT_OUTPUT"

              # Extract submission ID and get log if failed
              SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -E "^\s*id:" | head -1 | awk '{print $2}')
              if echo "$SUBMIT_OUTPUT" | grep -q "Invalid"; then
                echo "Notarization failed, fetching log..."
                xcrun notarytool log "$SUBMISSION_ID" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_PASSWORD" \
                  --team-id "$APPLE_TEAM_ID" \
                  notarization_log.json || true
                cat notarization_log.json || true
              fi

              # Staple if successful
              if echo "$SUBMIT_OUTPUT" | grep -q "Accepted"; then
                echo "Notarization successful, stapling..."
                xcrun stapler staple "release/$DMG_NAME"
              fi
            else
              echo "No .app found after extraction"
            fi
          else
            echo "No mac zip found"
          fi

          # Cleanup
          security delete-keychain $KEYCHAIN_PATH
          rm -f certificate.p12 entitlements.plist

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.version.outputs.version }}
          name: Release v${{ needs.version.outputs.version }}
          body: |
            ## The Council of Chalcedon - Visual Novel v${{ needs.version.outputs.version }}

            An educational kinetic novel re-enacting the Fourth Ecumenical Council (451 AD).

            ### Downloads
            - **Windows (Installer)**: `*-win.msi` - Recommended, creates Start Menu and Desktop shortcuts
            - **Windows (Portable)**: `*-win.zip` - No installation required
            - **macOS**: `*-macOS.dmg` (signed and notarized)
            - **Linux (AppImage)**: `*-linux.AppImage` - Recommended, runs on any distro
            - **Linux (Archive)**: `*-linux.tar.bz2` - Extract and run

            ### macOS Installation via Homebrew
            ```bash
            brew tap JohnVonDrashek/tap
            brew install --cask council-of-chalcedon
            ```
          files: release/*
          draft: false
          prerelease: false

      - name: Update Homebrew Tap
        if: success() && hashFiles('release/*.dmg') != ''
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          # Get the DMG URL and SHA
          VERSION="${{ needs.version.outputs.version }}"
          DMG_NAME="${{ env.PROJECT_NAME }}-${VERSION}-macOS.dmg"

          # Check if DMG exists
          if [ ! -f "release/${DMG_NAME}" ]; then
            echo "No DMG found, skipping Homebrew update"
            exit 0
          fi
          DMG_URL="https://github.com/${{ github.repository }}/releases/download/v${VERSION}/${DMG_NAME}"

          # Calculate SHA256 of the DMG
          SHA256=$(shasum -a 256 "release/${DMG_NAME}" | cut -d' ' -f1)

          # Clone the tap repo
          git clone https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/JohnVonDrashek/homebrew-tap.git tap-repo
          cd tap-repo

          # Create/update the cask
          cat > Casks/council-of-chalcedon.rb << EOF
          cask "council-of-chalcedon" do
            version "${VERSION}"
            sha256 "${SHA256}"

            url "${DMG_URL}"
            name "Council of Chalcedon"
            desc "Educational visual novel re-enacting the Fourth Ecumenical Council (451 AD)"
            homepage "https://github.com/JohnVonDrashek/council-of-chalcedon-vn"

            livecheck do
              url :url
              strategy :github_latest
            end

            app "CouncilOfChalcedon.app"

            zap trash: [
              "~/Library/Saved Application State/com.renpy.councilofchalcedon.savedState",
              "~/Library/RenPy/CouncilOfChalcedon",
            ]
          end
          EOF

          # Commit and push
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add Casks/council-of-chalcedon.rb
          git commit -m "Update council-of-chalcedon to v${VERSION}" || echo "No changes to commit"
          git push
